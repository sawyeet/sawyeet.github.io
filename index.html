<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>SawYeet</title>
        <link rel="stylesheet" href="css/styles.css">
    </head>

    <div class="headerd"><h1 class="header">SawYeet</h1></div>
    
    <div class="img"><img src="images/sawyer.jpg" alt="Sawyer Robot" width=50% ></div>

    <div class="contents">
        <ul style="list-style-type: none;">
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#design">Design</a></li>
            <li><a href="#impl">Implementation</a></li>
            <li><a href="#results">Results</a></li>
            <li><a href="#conc">Conculsion</a></li>
            <li><a href="#team">Team</a></li>
            <li><a href="#add">Additional Materials</a></li>
        </ul>
    </div>
    <hr>

    <div spellcheck="true" contenteditable="true">
        <div class="section_header">
            <h1 class="section"><span class="line" id="intro">Introduction</span></h1>
        </div>
        <div class="para">
            <b>(a) Describe the end goal of your project. </b>
            <br><br>
            The goal of the project was to create a system which would have the ability to return a ball thrown towards it. Based on the constraints that we worked with, our project involved using the Sawyer to intercept a balloon by blocking its path with the end-effector in real time. 
            <br><br>

            <b> (b) Why is this an interesting project? What interesting problems do you need to solve to make your solution work? </b>
            <br><br>
            The project is interesting because of the real time constraint that it has. This meant that no computation could be done beforehand, and we had to make everything work fast enough to move the sawyer within a very short time frame. Even if the sawyer was not able to “hit” the ball back, simply being able to block the ball in real time with the hardware constraints we were working with would be a challenge. There were many optimizations that could be done, ranging from the software to the construction of the ball itself. This made it a real engineering challenge. 
            <br>
            There were a lot of problems that we had to solve to be able to make this work. First of all, the Sawyer is an inherently slow robot. We had to solve the IK problem quickly, efficiently and reliably. We had to fix the planning to avoid the situation where the robot would follow a round-about trajectory for a small net change in position. Another big issue was to write a prediction algorithm for a projectile. This might seem very straightforward, but it becomes very hard when the jitter from the realsense and the tracking algorithm is considered. These problems are amplified when a balloon is used to slow down the projectile. In this case, the ball curves a lot, and if the velocity is slow enough, it simply drops to the ground because of the increased air resistance. This report will discuss each of our challenges in detail. 
            <br><br>

            <b>(c) In what real-world robotics applications could the work from your project be useful?</b>
            <br><br>

            Because the initial goal of the project was to build a table tennis bot, with more time and resources, it could be made into a robot that plays against an opponent. This can be used for training, practice and recreation. Apart from the obvious goals, the project ended up being one where a robot can intercept projectiles. This can potentially be a time saver on factory floors, where instead of a robot taking the time to move a tool or any other object from one place to another, it could throw it, and this system could use a net to catch it. 

        </div>
    </div>

    <div>
        <div class="section_header">
            <h1 class="section"><span class="line" id="design">Design</span></h1>
        </div>
        <div class="para">
            <b>(a) What design criteria must your project meet? What is the desired functionality? </b>
            <br><br>
            The main design criteria that we had was to be able to do this in real time, instead of having someone simulate a projectile motion by hand. This resulted in us using several optimizations that we would not have made were it not for this criteria. The project would have two parts to its functionality, the pitcher and the receiver. The pitcher is the person who would throw the ball from a distance, and the receiver is the robot. The only goal of the bot is to block the path of the projectile. 
            <br><br>
            <b>(b) Describe the design you chose. </b>
            <br><br>

            Our hardware design has 3 components: the ball, the depth camera, and the robot. The depth camera would be used to locate the ball in real world coordinates, and then use that information to predict its path, and its velocity. Based on this information, and the approximate movement speed of the Sawyer, we would move the end effector to the predicted location.
            <br>
            Based on this design, the software has three components. Ball localization, prediction, and actuation. The localization would use the ball and the depth camera. The prediction is purely software based, and will use the 3-D coordinates of the ball. And finally, the actuation uses the sawyer along with the predicted end position of the ball.
            <br>
            The design itself is relatively simple, but the main challenges appear when considering the limitations of each hardware item. 

            <br><br>
            <b>(c) What design choices did you make when you formulated your design? What trade-offs did you have to make?</b>
            <br><br> 

            The first one was related to the construction of the ball. There were several options: a tennis ball, a custom ball, and a balloon. The tennis ball was too heavy and small. Because the realsense had a low depth capture rate (15-30 frames at low resolutions), a fast motion would not work. The next option was to use a custom paper ball wrapped with neon tape which was made lighter by using a sponge core. Though the detection results here were much better, it was still too fast. So we moved on to using a balloon. The balloon was slow, and worked well with detection, but the prediction algorithm was not able to predict its non linear motion. In an effort to improve this, we used a half-inflated balloon with tape wrapped around it to increase the weight. This worked very well except for the fact that it would curve because of the asymmetrical shape and the spin on the throw. To counter the spin, we decided to simply put an underspin on the balloon, and this helped to reduce the side-spin.
            <br>
            The next one was the depth camera. The initial plan was to use two normal cameras and use stereo vision to find the ball, but constructing this algorithm, and dealing with its problems would not be possible under the time constraint that we had, so we decided to use the realsense instead. The realsense had issues with field of view. This meant that throwing the ball out of frame would give us only 1-3 frames to perform the prediction, and we had to throw the ball across the frame diagonally to capture as many frames as possible. 
            <br>
            One of the large constraints was the movement speeds of the Sawyer. To be able to react in time, we had to design the system to avoid path planning and IK solving and set the joint angles directly. To do this, we manually measured points in the 3d space and created a hashmap from end effector positions to joint angles. We could now avoid using an IK solver. 
            <br><br>
            <b>(d) How do these design choices impact how well the project meets design criteria that would be encountered in a real engineering application, such as robustness, durability, and efficiency? </b>
            <br><br>
            Each of the design choices were to make the computation faster and more reliable, while trying to solve the problem in real time. Without these optimizations, one would have to manually move the ball across the frame slowly in a projectile motion to work. By using the decision that we made, we were able to make the design more robust as it would now perform the prediction very accurately given that it received enough frames with the ball in it. However, for a real product, having a better camera with more FPS, and a larger FOV would make things work with a higher chance of success. 

        </div>
    </div>

    <div>
        <div class="section_header">
            <h1 class="section"><span class="line" id="impl">Implementation</span></h1>
        </div>
        <div class="para">
            <b>(a) Describe any hardware you used or built. Illustrate with pictures and diagrams.</b>
            <br><br> 

            There were 2 main hardware components. 
            <br>

            The first one is the Sawyer robot from the lab. This is a 7-DOF manipulator. 
            <br>

            The second one is the realsense camera. The camera has a max resolution of 720p at 15fps, and ___ at ___. The FOV is very small at ___ degrees.
            The last one is a piece of hardware that we built: The ball. The tennis ball that we tested worked well when held, but tracking failed when the ball was thrown relatively fast, and therefore the prediction failed too. So we ended up using a moderately filled balloon (to about 40% capacity), and wrapped with neon green duct tape. The tape not only improved segmentation and tracking, but also made the balloon heavier. This way it would follow a better projectile motion path rather than an unpredictable path. Because at the core, it was a balloon and had a larger surface area, we were able to throw it slowly, and this improved the tracking at “higher speeds”. 
            <br><br>

            <b>(b) What parts did you use to build your solution?</b>
            <br><br>

            <b>(c) Describe any software you wrote in detail. Illustrate with diagrams, flow charts, and/or other appropriate visuals. This includes launch files, URDFs, etc. 2 </b>
            <br><br>

            <b>(d) How does your complete system work? Describe each step. </b>
            <br><br>

        </div>
    </div>

    <div>
        <div class="section_header">
            <h1 class="section"><span class="line" id="results">Results</span></h1>
        </div>
        <div class="para">
            <b>(a) How well did your project work? What tasks did it perform? </b>
            <br><br>

            <b>(b) Illustrate with pictures and at least one video.</b>
            <br><br>

        </div>
    </div>

    <div>
        <div class="section_header">
            <h1 class="section"><span class="line" id="conc">Conclusion</span></h1>
        </div>
        <div class="para">
            <b>(a) Discuss your results. How well did your finished solution meet your design criteria? </b>
            <br><br>

            <b>(b) Did you encounter any particular difficulties? </b>
            <br><br>

            <b>(c) Does your solution have any flaws or hacks? What improvements would you make if you had additional time? </b>
            <br><br>

        </div>
    </div>

    <div>
        <div class="section_header">
            <h1 class="section"><span class="line" id="team">Team</span></h1>
        </div>
        <div class="para">
            <b>(a) Include names and short bios of each member of your project group. </b>
            <br><br>
            Dhruv Swarup: I am a student in EECS (RES) and did my undergrad in ECE. I have worked on projects involving PCB design, programming of embedded systems like building a small lidar-based robot and am good at prototyping with sensors and actuators. I have also worked on software projects involving Python, C, and C++ (mainly on Linux). I have also dabbled in web development, both frontend, and backend.
            <br><br>
            <b>(b) Describe the major contributions of each team member. </b>
            <br><br>
            Dhruv Swarup: I wrote the code for tracking as well as the actuation. For the tracking I wrote a color segmentation script, along with contour detection, and centroid calculation. From there, I extracted the 3d coordinates of the point using the depth information from the realsense. I also wrote all of that in C++ using a Kalman filter, but due to some other issues, we decided to only use the Python code and implement a Kalman filter from scratch. In the IK code, I wrote a method of first subscribing to the predicted point, and then finding the closest hardcoded end-effector point, and looking up its IK solution. Then the code would command the Sawyer to move to that position. I also helped with the tuning of the Kalman filter parameters and debugging the code integration. 
        </div>
    </div>

    <div>
        <div class="section_header">
            <h1 class="section"><span class="line" id="add">Additional Materials</span></h1>
        </div>
        <div class="para">
            <b>(a) code, URDFs, and launch files you wrote </b>
            <br><br>

            <b>(b) CAD models for any hardware you designed </b>
            <br><br>

            <b>(c) data sheets for components used in your system </b>
            <br><br>

            <b>(d) any additional videos, images, or data from your finished solution </b>
            <br><br>

            <b>(e) links to other public sites (e.g., GitHub), if that is where your files are stored</b>
            <br><br>

        </div>
    </div>

</html>